<!DOCTYPE html>
<html>

<head>
    <title>MultiCass</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            border: 0;
            box-sizing: border-box;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background-color: black;
        }
         #middle {
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
        }
        @font-face {
            font-family: digital7; /* set name */
            src: url(./led.ttf); /* url of the font */
        }
        #mycanvas {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font: "digital7";
        }
    </style>
    <link rel="preload" href="./led.ttf" as="font" type="font/ttf" crossorigin>
</head>

<body>
    <div id="middle">

        <canvas id="mycanvas"></canvas>
    </div>
    
<script type="module">
function truncateDecimals(number, digits) {
    var multiplier = Math.pow(10, digits),
        adjustedNum = number * multiplier,
        truncatedNum = Math[adjustedNum < 0 ? 'ceil' : 'floor'](adjustedNum);

    return truncatedNum / multiplier;
};

function numberWithSpaces(x) {
    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
}

//============================  CLASS ISORECT  ====================================
class IsoRect {
    constructor(settings) {
      this.position = settings.position;
      this.width = settings.width;
      this.height = settings.height;
      this.direction = settings.direction;
      this.color = settings.color;
      this.angle = settings.angle ? settings.angle : 30
}
render() {
      ctx.save();
      ctx.fillStyle = this.color;
      const angle = (Math.PI / 180) * this.angle;
      ctx.translate(
        this.position[0] + this.width / 2,
        this.position[1] + this.height / 2,
      );
      if (this.direction === "side") {
        ctx.rotate(angle);
        ctx.transform(1, 0, Math.tan(angle), 1, 0, 0);
        ctx.scale(1, Math.cos(angle));
      } else if (this.direction === "front") {
        // front
        ctx.rotate(-angle);
        ctx.transform(1, 0, Math.tan(angle * -1), 1, 0, 0);
        ctx.scale(1, Math.cos(angle));
      } else {
        // plant
        ctx.rotate(-angle);
        ctx.transform(1, 0, Math.tan(-angle * (90-this.angle*2) / this.angle *  -1), 1, 0, 0);
        ctx.scale(1, Math.cos(-angle));
      }
      ctx.translate(
        -(this.position[0] + this.width / 2),
        -(this.position[1] + this.height / 2),
      );
      ctx.strokeStyle = "black";
      ctx.lineWidth = "1";
      ctx.fillRect(
      //ctx.rect(
        this.position[0],
        this.position[1],
        this.width,
        this.height,
      );
      ctx.stroke();
      if (this.direction === "plant") {
            ctx.fillStyle = "blue";
            ctx.fillText("HEADER HASH", 21*ctx.canvas.width/64, 26*ctx.canvas.width/128);
            ctx.fillStyle = "lightblue";
            ctx.fillText(HEADER.substring(0,11), 21*ctx.canvas.width/64, 32*ctx.canvas.width/128);
            ctx.fillText(HEADER.substring(11,22), 21*ctx.canvas.width/64, 38*ctx.canvas.width/128);
            ctx.fillText(HEADER.substring(22,33), 21*ctx.canvas.width/64, 44*ctx.canvas.width/128);
            ctx.fillText(HEADER.substring(33,44), 21*ctx.canvas.width/64, 50*ctx.canvas.width/128);
            ctx.fillText(HEADER.substring(44,55), 21*ctx.canvas.width/64, 56*ctx.canvas.width/128);
            ctx.fillText(HEADER.substring(55,66), 21*ctx.canvas.width/64, 62*ctx.canvas.width/128);
        }

      if (this.direction === "front") {
            ctx.fillStyle = "green";
            ctx.fillText("BLOCK HEIGHT", 32*ctx.canvas.width/64, 59*ctx.canvas.width/128);
            ctx.fillText("Index ", 32*ctx.canvas.width/64, 71*ctx.canvas.width/128);
            ctx.fillText("AVG B T ", 42*ctx.canvas.width/64, 77*ctx.canvas.width/128);
            ctx.fillText("DIFF ", 32*ctx.canvas.width/64, 83*ctx.canvas.width/128);
            ctx.fillText("PEAK WEIGHT", 32*ctx.canvas.width/64, 89*ctx.canvas.width/128);
            
            ctx.fillStyle = "lime";
            ctx.fillText(numberWithSpaces(HEIGHT), 32*ctx.canvas.width/64, 65*ctx.canvas.width/128);
            ctx.fillText(SPI, 44*ctx.canvas.width/64, 71*ctx.canvas.width/128);
            ctx.fillText(ABT, 32*ctx.canvas.width/64, 77*ctx.canvas.width/128);
            ctx.fillText(DIF, 42*ctx.canvas.width/64, 83*ctx.canvas.width/128);
            ctx.fillText(WEIGHT, 32*ctx.canvas.width/64, 95*ctx.canvas.width/128);
        }
      if (this.direction === "side") {
            ctx.fillStyle = "tomato";
            ctx.fillText("XCH MEMPOOL", 19*ctx.canvas.width/128, 59*ctx.canvas.width/128);
            ctx.fillText("SIZE", 19*ctx.canvas.width/128, 65*ctx.canvas.width/128);
            ctx.fillText("COST", 19*ctx.canvas.width/128, 71*ctx.canvas.width/128);
            ctx.fillText("FEES", 19*ctx.canvas.width/128, 77*ctx.canvas.width/128);
            ctx.fillText("TOT NETSPACE", 19*ctx.canvas.width/128, 83*ctx.canvas.width/128);
            ctx.fillText("by cassxch", 19*ctx.canvas.width/128, 95*ctx.canvas.width/128);
            
            ctx.fillStyle = "red";
            ctx.fillText(MEMSIZE, 37*ctx.canvas.width/128, 65*ctx.canvas.width/128);
            ctx.fillText(truncateDecimals(MEMCOST/1000000000000, 6), 37*ctx.canvas.width/128, 71*ctx.canvas.width/128);
            ctx.fillText(truncateDecimals(MEMFEES/1000000000000, 6), 37*ctx.canvas.width/128, 77*ctx.canvas.width/128);
            ctx.fillText(truncateDecimals(SPACE/1000000000000000000, 5) + " EB", 19*ctx.canvas.width/128, 89*ctx.canvas.width/128);
        }
      ctx.restore();
    }
  }

//============================  BLOCKCHAIN STATE  ====================================
function blockchain_state() {
    fetch("https://api.coinset.org/get_blockchain_state", {
      method: "POST",
      headers: { "Content-Type": "application/json", },
      body: JSON.stringify({}),
    })
    .then((response) => {
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }
    return response.json();
    })
    .then((data) => {
        //console.log('Blockchain State:', data);
        
        ABT = data.blockchain_state.average_block_time + "  s";
        DIF = data.blockchain_state.difficulty;
        MEMFEES = data.blockchain_state.mempool_fees;
        MEMCOST = data.blockchain_state.mempool_cost;
        MEMSIZE = data.blockchain_state.mempool_size;
        DEF = data.blockchain_state.peak.deficit;
        HEIGHT = data.blockchain_state.peak.height;
        OVERF = data.blockchain_state.peak.overflow;
        RITER = data.blockchain_state.peak.required_iters;
        SPI = data.blockchain_state.peak.signage_point_index + "-64";
        SSITERS = data.blockchain_state.peak.sub_slot_iters;
        WEIGHT = data.blockchain_state.peak.weight;
        SPACE = data.blockchain_state.space;
        HEADER = data.blockchain_state.peak.header_hash;

        drawDATA(data);
    })
    .catch((error) => {
        console.error('Fetch error:', error);
    });
};

//============================  DRAW DATA  ====================================
function drawDATA(data) {
    ctx.font = 4*canvas.width/100 + "px digital7";
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
new IsoRect({
    position: [36*ctx.canvas.width/256, 53*ctx.canvas.width/128],
    width: 1.5*ctx.canvas.width/4,
    height: 90*(1.5*ctx.canvas.width/4)/100,
    direction: "side",
    color: mycolor,
    angle: 26.5,
  }).render();
new IsoRect({
    position: [124*ctx.canvas.width/256, 53*ctx.canvas.width/128],
    width: 1.5*ctx.canvas.width/4,
    height: 90*(1.5*ctx.canvas.width/4)/100,
    direction: "front",
    color: mycolor,
    angle: 26.5,
  }).render();
new IsoRect({
    position: [5*ctx.canvas.width/16, 5*ctx.canvas.width/32+1],
    width: 1.5*ctx.canvas.width/4,
    height: 90*(1.5*ctx.canvas.width/4)/100-2,
    direction: "plant",
    color: mycolor,
    angle: 26.5,
  }).render();
};



var mycolor = "#00000000";
var ABT;
var DIF;
var MEMFEES;
var MEMSIZE;
var DEF;
var HEIGHT;
var OVERF;
var RITER;
var SPI;
var SSITERS;
var TITERS;
var WEIGHT;
var SPACE;
var MEMCOST;
var HEADER;


var canvas = document.getElementById("mycanvas");
var ctx = canvas.getContext("2d");
var w = document.getElementById("middle").clientWidth;
var h = document.getElementById("middle").clientHeight;

if (w < h) {
    ctx.canvas.width = w;
    ctx.canvas.height = w;
} else {
    ctx.canvas.width = h;
    ctx.canvas.height = h;
}

ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.fillStyle = "black";
ctx.fillRect(0, 0, canvas.width, canvas.height);
blockchain_state();

const ws = new WebSocket('wss://api.coinset.org/ws');
ws.onmessage = (event) => {
  const message = JSON.parse(event.data);
  switch (message.type) {
    case 'offer':
      //console.log('New offer:', message.data.offer);
      break;
    case 'peak':
      //console.log('New block height:', message.data.height);
        blockchain_state();
      break;
    case 'transaction':
      //console.log('New transaction:', message.data.id);
      break;
  }
};

    </script>
</body>


</html>
